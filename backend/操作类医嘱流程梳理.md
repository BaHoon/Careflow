# 操作类医嘱（OperationOrder）完整流程梳理

## 一、核心架构概览

### 1.1 数据模型

#### OperationOrder（操作医嘱）
```96:104:backend/CareFlow.Core/Models/Medical/MedicalOrder.cs
    // 操作医嘱 (OPERATION_ORDER)
    [Table("OperationOrders")]
    public class OperationOrder : MedicalOrder
    {
        public string OpId { get; set; } = null!;             // 操作代码
        public bool Normal { get; set; }             // 正常/异常标识
        public string FrequencyType { get; set; } = null!;    // 频次类型(每天一次/一天几次)
        public string FrequencyValue { get; set; } = null!;   // 频次值
    }
```

**继承自 MedicalOrder 的字段：**
- `PatientId`: 患者ID
- `DoctorId`: 医生ID
- `NurseId`: 负责护士ID（自动分配）
- `PlantEndTime`: 医嘱计划结束时间
- `IsLongTerm`: 是否长期医嘱
- `Status`: 医嘱状态（Pending/Completed/Cancelled）
- `Remarks`: 备注

#### ExecutionTask（执行任务）
```8:70:backend/CareFlow.Core/Models/Nurse/ExecutionTask.cs
public class ExecutionTask : EntityBase<long>
{
    public long MedicalOrderId { get; set; } // 来源医嘱
    [ForeignKey("MedicalOrderId")]
    public MedicalOrder MedicalOrder { get; set; }= null!;

    public string PatientId { get; set; } = null!; // 冗余方便查询
    [ForeignKey("PatientId")]
    public Patient Patient { get; set; } = null!;

    /// <summary>
    /// 任务类别：决定了前端的交互流程和后台的状态流转逻辑 (Immediate, Duration, ResultPending, etc.)
    /// </summary>
    public TaskCategory Category { get; set; }

    // --- 时间与执行人 (双人双时) ---

    // 1. 计划时间
    public DateTime PlannedStartTime { get; set; }

    // 2. 开始执行 (对于所有类别：扫码时刻)
    public DateTime? ActualStartTime { get; set; }
    /// <summary>
    /// 发起护士 (扫码开始的人)
    /// 对于即刻类(Immediate)，也是完成人
    /// </summary>
    public string? ExecutorStaffId { get; set; } // 实际扫码的人
    [ForeignKey("ExecutorStaffId")]
    public Nurse? Executor { get; set; }

    // 3. 结束/完成执行 (对于持续类、结果类、记录类)
    public DateTime? ActualEndTime { get; set; }
    /// <summary>
    /// 结束护士 (点击结束/录入结果的人)
    /// 适用于：Duration(拔针), ResultPending(录结果), DataCollection(提交), Verification(核对完)
    /// </summary>
    public string? CompleterNurseId { get; set; }
    [ForeignKey("CompleterNurseId")]
    public Nurse? CompleterNurse { get; set; }

    // 状态
    public string Status { get; set; } = "Pending"; // Pending, Running, Completed, Skipped, Cancelled
    public bool IsRolledBack { get; set; } = false; // 是否已回滚
    
    /// <summary>
    /// [输入] 任务上下文/定义数据 (由系统生成任务时写入)
    /// 例子：TaskType, Title, SupplyList 等
    /// </summary>
    public string DataPayload { get; set; } = string.Empty;
    
    /// <summary>
    /// [输出] 任务执行结果 (由护士操作后写入)
    /// 用途：记录"测量的数值"、"实际扫描的条码"、"皮试结果"
    /// 初始为空，Task完成时必填（取决于业务逻辑）
    /// </summary>
    public string? ResultPayload { get; set; }

    public string ExceptionReason { get; set; } = string.Empty;
    
    // 审计字段
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime? LastModifiedAt { get; set; }
}
```

### 1.2 任务类别（TaskCategory）

```3:19:backend/CareFlow.Core/Enums/TaskCategory.cs
    public enum TaskCategory
    {
        // 1. 即刻执行类 (如：单次给药、更换引流袋) -> 扫码即完成
        Immediate = 1,

        // 2. 持续执行类 (如：输液、吸氧) -> 扫码开始，再次扫码结束
        Duration = 2,

        // 3. 结果等待类 (如：皮试、血糖) -> 扫码开始，录入结果后结束
        ResultPending = 3,

        // 4. 护理记录类 (如：体温单) -> 扫码患者，录入数据提交
        DataCollection = 4,

        // 5. 核对类 (如：取药) -> 扫描任务，逐个扫描药品码后结束
        Verification = 5
    }
```

**操作类医嘱使用的类别：**
- `Immediate (1)`: 即刻执行，扫码即完成（如：更换引流袋、更换敷料、口腔护理）
- `Duration (2)`: 持续执行，需要开始和结束时间（如：持续吸氧、持续导尿、持续静脉输液）
- `ResultPending (3)`: 需要等待结果，录入结果后完成（如：血糖监测、血压监测、体温监测）

### 1.3 操作代码映射

```47:80:backend/CareFlow.Application/Services/MedicalOrder/OperationExecutionTaskFactory.cs
        /// <summary>
        /// 根据操作代码（OpId）获取任务类别
        /// </summary>
        private TaskCategory GetTaskCategoryFromOpId(string opId)
        {
            return opId switch
            {
                // Immediate 类：即刻执行，扫码即完成
                "OP001" => TaskCategory.Immediate,  // 更换引流袋
                "OP004" => TaskCategory.Immediate,  // 更换敷料
                "OP005" => TaskCategory.Immediate,  // 导尿
                "OP008" => TaskCategory.Immediate,  // 口腔护理
                "OP009" => TaskCategory.Immediate,  // 会阴护理
                "OP010" => TaskCategory.Immediate,  // 皮肤护理
                "OP015" => TaskCategory.Immediate,  // 翻身拍背
                
                // Duration 类：持续执行，需要开始和结束时间
                "OP002" => TaskCategory.Duration,   // 持续吸氧
                "OP006" => TaskCategory.Duration,   // 鼻饲
                "OP007" => TaskCategory.Duration,   // 雾化吸入
                "OP011" => TaskCategory.Duration,   // 持续心电监护
                "OP012" => TaskCategory.Duration,   // 持续导尿
                "OP013" => TaskCategory.Duration,   // 持续胃肠减压
                "OP014" => TaskCategory.Duration,   // 持续静脉输液
                
                // ResultPending 类：需要等待结果，录入结果后完成
                "OP003" => TaskCategory.ResultPending, // 血糖监测
                "OP016" => TaskCategory.ResultPending, // 血压监测
                "OP017" => TaskCategory.ResultPending, // 体温监测
                "OP018" => TaskCategory.ResultPending, // 尿量监测
                "OP019" => TaskCategory.ResultPending, // 意识状态评估
                "OP020" => TaskCategory.ResultPending, // 疼痛评估
                
                // 默认为立即执行
                _ => TaskCategory.Immediate
            };
        }
```

## 二、完整业务流程

### 2.1 医嘱创建流程

```
医生创建操作医嘱
    ↓
POST /api/OperationOrder/create
    ↓
OperationOrderController.CreateOperationOrder()
    ↓
OperationOrderManager.CreateOperationOrderAsync()
    ├── 1. 设置默认值（Status="Pending", CreateTime=UtcNow）
    ├── 2. 保存到数据库（OperationOrders表 + MedicalOrders基表）
    ├── 3. 自动分配护士（根据患者床位和排班）
    │   └── INurseAssignmentService.CalculateResponsibleNurseAsync()
    └── 4. 自动生成执行任务（立即拆分任务）
        └── OperationOrderTaskService.GenerateExecutionTasksAsync()
    ↓
返回 OrderId 和 AssignedNurseId
```

**关键代码：**

```35:104:backend/CareFlow.Application/Services/MedicalOrder/OperationOrderManager.cs
        public async Task<OperationOrder> CreateOperationOrderAsync(OperationOrder order)
        {
            // 1. 设置默认值
            if (string.IsNullOrEmpty(order.Status))
            {
                order.Status = "Pending"; // 初始状态
            }

            if (order.CreateTime == default)
            {
                order.CreateTime = DateTime.UtcNow;
            }

            // 2. 先保存到数据库（确保实体有ID，用于后续更新）
            // 注意：由于使用 TPT 继承，EF Core 会同时保存到 MedicalOrders 基表和 OperationOrders 子表
            await _operationRepo.AddAsync(order);

            _logger.LogInformation("操作医嘱已保存到数据库: OrderId={OrderId}, OpId={OpId}, PatientId={PatientId}", 
                order.Id, order.OpId, order.PatientId);

            // 3. 自动分配护士（如果未指定）- 在保存后分配，然后更新
            if (string.IsNullOrEmpty(order.NurseId))
            {
                try
                {
                    // 操作医嘱使用当前时间查询排班
                    var targetTime = DateTime.UtcNow;
                    
                    var responsibleNurseId = await _nurseAssignmentService
                        .CalculateResponsibleNurseAsync(order.PatientId, targetTime);
                    
                    if (!string.IsNullOrEmpty(responsibleNurseId))
                    {
                        order.NurseId = responsibleNurseId;
                        // 更新数据库，确保 NurseId 被保存到基表 MedicalOrders
                        await _operationRepo.UpdateAsync(order);
                        _logger.LogInformation("✅ 已分配负责护士: {NurseId} 给操作医嘱 {OrderId}", 
                            responsibleNurseId, order.Id);
                    }
                    else
                    {
                        _logger.LogWarning("⚠️ 未找到负责护士，操作医嘱 {OrderId} 的 NurseId 将保持为空", order.Id);
                    }
                }
                catch (Exception nurseEx)
                {
                    _logger.LogError(nurseEx, "❌ 计算负责护士失败，操作医嘱 {OrderId}", order.Id);
                    // 护士分配失败不影响医嘱创建，继续执行
                }
            }
            else
            {
                _logger.LogInformation("操作医嘱 {OrderId} 已指定护士: {NurseId}", order.Id, order.NurseId);
            }

            // 4. 自动生成执行任务（医嘱下达后立即拆分任务）
            try
            {
                _logger.LogInformation("开始为操作医嘱 {OrderId} 自动生成执行任务", order.Id);
                var generatedTasks = await _taskService.GenerateExecutionTasksAsync(order);
                _logger.LogInformation("✅ 已为操作医嘱 {OrderId} 自动生成 {Count} 个执行任务", order.Id, generatedTasks.Count);
            }
            catch (Exception taskEx)
            {
                _logger.LogError(taskEx, "❌ 自动生成执行任务失败，操作医嘱 {OrderId}，但不影响医嘱创建", order.Id);
                // 任务生成失败不影响医嘱创建，继续执行
            }

            return order;
        }
```

### 2.2 任务生成流程

```
OperationOrderTaskService.GenerateExecutionTasksAsync()
    ├── 1. 验证医嘱真实性（从数据库查询）
    ├── 2. 状态检查（不能是Cancelled）
    ├── 3. 操作特有字段验证
    │   ├── OpId 不能为空
    │   ├── FrequencyType 不能为空
    │   ├── FrequencyValue 不能为空
    │   ├── PlantEndTime > CreateTime
    │   └── IsLongTerm 与 FrequencyType 匹配验证
    ├── 4. 调用工厂生成任务
    │   └── OperationExecutionTaskFactory.CreateTasks()
    ├── 5. 批量保存任务到 ExecutionTasks 表
    ├── 6. 为每个任务生成条形码索引（BarcodeIndexes 表）
    └── 7. 检查并更新医嘱状态
```

**任务生成工厂核心逻辑：**

```82:111:backend/CareFlow.Application/Services/MedicalOrder/OperationExecutionTaskFactory.cs
        public List<ExecutionTask> CreateTasks(CareFlow.Core.Models.Medical.MedicalOrder medicalOrder)
        {
            // 1. 类型安全检查
            if (medicalOrder is not OperationOrder operationOrder)
            {
                throw new ArgumentException("OperationExecutionTaskFactory 仅支持 OperationOrder 类型的医嘱", nameof(medicalOrder));
            }

            // 2. 获取操作的任务类别
            var taskCategory = GetTaskCategoryFromOpId(operationOrder.OpId);

            var tasks = new List<ExecutionTask>();

            // 3. 根据 IsLongTerm 决定任务生成策略
            if (operationOrder.IsLongTerm)
            {
                // 长期医嘱：根据"x天y次"生成多个任务
                GenerateLongTermTasks(operationOrder, tasks, taskCategory);
            }
            else
            {
                // 临时医嘱：只生成1个任务
                GenerateOneTimeTask(operationOrder, tasks, taskCategory);
            }

            // 4. 验证和过滤任务时间：如果只生成一个任务且时间已过则报错，如果多个任务则删除时间已过的任务
            ValidateAndFilterTaskTime(tasks);

            return tasks;
        }
```

#### 2.2.1 长期医嘱任务生成（IsLongTerm=true）

**规则：**
- `FrequencyType` 格式：`"x天y次"`（如 `"1天3次"`）
  - 如果 x=1，表示每天执行 y 次
  - 如果 x=2，表示每2天执行 y 次（第1天、第3天、第5天...各执行 y 次）
- `FrequencyValue` 格式：时间点列表，用逗号或分号分隔（如 `"08:00,12:00,16:00"`），应包含 y 个时间点

**计算逻辑：**
1. 计算从当前日期（CreateTime.Date）到 PlantEndTime.Date 的总天数
2. 计算包含多少个 x 天周期：从第1天开始，每 x 天为一个周期，直到超过结束日期
3. 任务数量 = 周期数 × y
4. 每个任务的 PlannedStartTime = 对应日期 + FrequencyValue 中的时间点

**示例：**
- 医嘱：1天3次，时间点 08:00,12:00,16:00，医嘱进行3天（从2024-01-01到2024-01-03）
- 总天数：3天
- 周期数：3个周期（第1天、第2天、第3天各为一个周期，因为 x=1）
- 任务数量：3 × 3 = 9个任务
- 任务时间：
  - 第1天：2024-01-01 08:00, 2024-01-01 12:00, 2024-01-01 16:00
  - 第2天：2024-01-02 08:00, 2024-01-02 12:00, 2024-01-02 16:00
  - 第3天：2024-01-03 08:00, 2024-01-03 12:00, 2024-01-03 16:00

**关键代码：**

```135:191:backend/CareFlow.Application/Services/MedicalOrder/OperationExecutionTaskFactory.cs
        private void GenerateLongTermTasks(OperationOrder order, List<ExecutionTask> tasks, TaskCategory taskCategory)
        {
            // 解析FrequencyType：提取x（天数）和y（次数）
            var frequencyParts = order.FrequencyType.Split('天');
            if (frequencyParts.Length != 2)
            {
                throw new ArgumentException($"长期医嘱的FrequencyType格式错误，应为'x天y次'，当前值：{order.FrequencyType}");
            }

            if (!int.TryParse(frequencyParts[0].Trim(), out int daysPerCycle))
            {
                throw new ArgumentException($"无法解析天数，FrequencyType：{order.FrequencyType}");
            }

            var timesPart = frequencyParts[1].Replace("次", "").Trim();
            if (!int.TryParse(timesPart, out int timesPerCycle))
            {
                throw new ArgumentException($"无法解析次数，FrequencyType：{order.FrequencyType}");
            }

            // 解析FrequencyValue：时间点列表（应包含y个时间点）
            var timePoints = ParseTimePoints(order.FrequencyValue);
            if (timePoints.Count != timesPerCycle)
            {
                throw new ArgumentException($"时间点数量({timePoints.Count})与次数({timesPerCycle})不匹配");
            }

            // 计算从当前日期（CreateTime.Date）到PlantEndTime.Date的总天数
            var startDate = order.CreateTime.Date;
            var endDate = order.PlantEndTime.Date;

            // 按周期生成任务：从startDate开始，每x天为一个周期
            // 例如：x=1，从第1天开始，每天执行y次
            // 例如：x=2，从第1天开始，每2天执行y次（第1天、第3天、第5天...）
            var currentDate = startDate;
            int cycleIndex = 0;

            while (currentDate <= endDate)
            {
                // 为当前周期的这一天生成y个任务（对应y个时间点）
                foreach (var timePoint in timePoints)
                {
                    // 任务的PlannedStartTime = 当前日期 + FrequencyValue中的时间点
                    var plannedTime = currentDate.Add(timePoint);
                    
                    // 确保不超过结束时间
                    if (plannedTime <= order.PlantEndTime)
                    {
                        tasks.Add(CreateOperationTask(order, plannedTime, taskCategory));
                    }
                }

                // 移动到下一个周期：当前日期 + x天
                cycleIndex++;
                currentDate = startDate.AddDays(cycleIndex * daysPerCycle);
            }
        }
```

#### 2.2.2 临时医嘱任务生成（IsLongTerm=false）

**规则：**
- `FrequencyType` 必须为 `"一次性"`
- `FrequencyValue` 为 `"立即"` 或固定时间点（如 `"14:30"`）

**PlannedStartTime 计算逻辑：**
- 如果 `FrequencyValue="立即"`：PlannedStartTime = 当前日期当前时间点（DateTime.UtcNow）
- 如果 `FrequencyValue=固定时间点`（如 `"14:30"`）：PlannedStartTime = 当前日期 + 固定时间点

**关键代码：**

```202:247:backend/CareFlow.Application/Services/MedicalOrder/OperationExecutionTaskFactory.cs
        private void GenerateOneTimeTask(OperationOrder order, List<ExecutionTask> tasks, TaskCategory taskCategory)
        {
            // 验证FrequencyType
            if (order.FrequencyType != "一次性")
            {
                throw new ArgumentException($"临时医嘱的FrequencyType必须为'一次性'，当前值：{order.FrequencyType}");
            }

            DateTime plannedTime;

            // 解析FrequencyValue
            if (order.FrequencyValue == "立即" || string.IsNullOrWhiteSpace(order.FrequencyValue))
            {
                // 立即执行：PlannedStartTime = 当前日期当前时间点
                plannedTime = DateTime.UtcNow;
            }
            else
            {
                // 固定时间点：解析时间字符串（如"14:30"）
                if (TimeSpan.TryParse(order.FrequencyValue, out var timeSpan))
                {
                    // PlannedStartTime = 当前日期 + 固定时间点
                    plannedTime = DateTime.UtcNow.Date.Add(timeSpan);
                }
                else
                {
                    // 尝试解析完整日期时间
                    if (DateTime.TryParse(order.FrequencyValue, out var dateTime))
                    {
                        plannedTime = dateTime;
                    }
                    else
                    {
                        throw new ArgumentException($"无法解析FrequencyValue时间格式：{order.FrequencyValue}");
                    }
                }
            }

            // 确保计划时间不超过结束时间
            if (plannedTime > order.PlantEndTime)
            {
                throw new ArgumentException($"计划执行时间({plannedTime})不能晚于医嘱结束时间({order.PlantEndTime})");
            }

            tasks.Add(CreateOperationTask(order, plannedTime, taskCategory));
        }
```

#### 2.2.3 任务时间验证和过滤

**规则：**
1. 如果只生成一个任务，检查 PlannedStartTime 是否已过，如果已过则报错且不产生任务
2. 如果生成多个任务（长期医嘱），自动删除计划开始时间早于当前时间的任务

**关键代码：**

```380:417:backend/CareFlow.Application/Services/MedicalOrder/OperationExecutionTaskFactory.cs
        private void ValidateAndFilterTaskTime(List<ExecutionTask> tasks)
        {
            var currentTime = DateTime.UtcNow;
            
            // 如果只生成一个任务，需要检查时间是否已过
            if (tasks.Count == 1)
            {
                var task = tasks[0];
                
                // 如果任务的计划开始时间已经过去，报错且不产生任务
                if (task.PlannedStartTime < currentTime)
                {
                    tasks.Clear(); // 清空任务列表，不产生任务
                    throw new ArgumentException(
                        $"不能选择已经过去的时间。任务的计划开始时间({task.PlannedStartTime:yyyy-MM-dd HH:mm:ss}) " +
                        $"早于当前时间({currentTime:yyyy-MM-dd HH:mm:ss})。请选择未来的时间。");
                }
            }
            // 如果生成多个任务（长期医嘱），自动删除计划开始时间早于当前时间的任务
            // 注意：这里会删除所有时间已过的任务，包括今天已过的时间点
            // 但后续天数的所有时间点任务都会正常保留（因为它们的PlannedStartTime >= currentTime）
            else if (tasks.Count > 1)
            {
                var tasksToRemove = tasks.Where(t => t.PlannedStartTime < currentTime).ToList();
                
                foreach (var task in tasksToRemove)
                {
                    tasks.Remove(task);
                }
                
                // 如果删除后没有剩余任务，报错
                if (!tasks.Any())
                {
                    throw new ArgumentException(
                        $"所有任务的计划开始时间都早于当前时间({currentTime:yyyy-MM-dd HH:mm:ss})。请调整医嘱的时间范围。");
                }
            }
        }
```

#### 2.2.4 任务创建（通用方法）

**关键代码：**

```284:335:backend/CareFlow.Application/Services/MedicalOrder/OperationExecutionTaskFactory.cs
        private ExecutionTask CreateOperationTask(OperationOrder order, DateTime plannedTime, TaskCategory category)
        {

            // 确定 TaskType 字符串
            string taskType = category switch
            {
                TaskCategory.Duration => "DURATION_OPERATION",
                TaskCategory.ResultPending => "RESULT_PENDING_OPERATION",
                _ => "IMMEDIATE_OPERATION"
            };

            // 为Category=3（ResultPending）的任务生成结构化数据模板（放在DataPayload中供前端使用）
            // 但ResultPayload初始为null，等护士输入后才算任务结束
            string? resultPayloadTemplate = null;
            if (category == TaskCategory.ResultPending)
            {
                resultPayloadTemplate = GenerateResultPayloadTemplate(order.OpId);
            }

            var dataPayload = new
            {
                TaskType = taskType,
                Title = GetOperationName(order.OpId),
                Description = $"操作代码：{order.OpId}，频次：{order.FrequencyType} {order.FrequencyValue}",
                OpId = order.OpId,
                Normal = order.Normal,
                FrequencyType = order.FrequencyType,
                FrequencyValue = order.FrequencyValue,
                RequiresScan = true,
                IsImmediate = category == TaskCategory.Immediate,
                ExecutionMode = category == TaskCategory.Immediate ? "立即执行" 
                               : category == TaskCategory.Duration ? "持续执行"
                               : "等待结果",
                ResultPayloadTemplate = resultPayloadTemplate // Category=3的任务包含结果模板（供前端使用）
            };

            return new ExecutionTask
            {
                MedicalOrderId = order.Id,
                PatientId = order.PatientId,
                Category = category,
                PlannedStartTime = plannedTime, // 所有任务都有明确的计划开始时间
                Status = "Pending",
                CreatedAt = DateTime.UtcNow,
                ResultPayload = null, // 初始为null，Category=3的任务在护士输入结果后才算任务结束
                DataPayload = JsonSerializer.Serialize(dataPayload, new JsonSerializerOptions 
                { 
                    PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                    DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
                })
            };
        }
```

### 2.3 条形码生成流程

**每个任务生成时自动创建条形码索引：**

```291:310:backend/CareFlow.Application/Services/MedicalOrder/OperationOrderTaskService.cs
        /// <summary>
        /// 为任务生成条形码索引（用于扫码验证患者身份）
        /// </summary>
        private async Task GenerateBarcodeForTask(ExecutionTask task)
        {
            try
            {
                var barcodeIndex = new BarcodeIndex
                {
                    Id = $"Exec-{task.Id}", 
                    TableName = "ExecutionTasks",
                    RecordId = task.Id.ToString()
                };
                await _barcodeRepository.AddAsync(barcodeIndex);
                
                _logger.LogDebug("为任务 {TaskId} 生成条形码索引成功", task.Id);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "为任务 {TaskId} 生成条形码失败", task.Id);
                // 条形码生成失败不影响任务创建，只记录日志
            }
        }
```

**获取任务条形码图片：**

```136:158:backend/CareFlow.WebApi/Controller/OperationOrderTaskController.cs
    [HttpGet("task/{taskId}/barcode")]
    public async Task<IActionResult> GetTaskBarcode(long taskId)
    {
        try
        {
            var task = await _executionTaskRepository.GetByIdAsync(taskId);
            if (task == null) return NotFound("任务不存在");

            var barcodeIndex = new BarcodeIndex
            {
                TableName = "ExecutionTasks",
                RecordId = taskId.ToString()
            };

            var imageBytes = await _barcodeService.GenerateBarcodeAsync(barcodeIndex);
            return File(imageBytes, "image/png", $"ExecTask-{taskId}.png");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "获取条形码失败: {Message}", ex.Message);
            return BadRequest($"获取条形码失败: {ex.Message}");
        }
    }
```

### 2.4 任务执行流程

#### 2.4.1 Immediate 类任务（即刻执行）

```
护士查看任务列表
    ↓
GET /api/Nursing/my-tasks
    ↓
护士选择任务，扫码验证（可选）
    ↓
POST /api/BarcodeMatching/validate
    ├── 扫描执行任务条形码
    ├── 扫描患者腕带条形码
    └── 验证：患者ID匹配、时间窗口（±30分钟）、任务状态
    ↓
验证通过，开始执行
    ↓
更新任务状态为 Running
    ├── ActualStartTime = DateTime.UtcNow
    ├── ExecutorStaffId = 当前护士ID
    └── Status = "Running"
    ↓
立即完成（扫码即完成）
    ↓
更新任务状态为 Completed
    ├── ActualEndTime = DateTime.UtcNow
    ├── CompleterNurseId = 当前护士ID（与ExecutorStaffId相同）
    └── Status = "Completed"
```

#### 2.4.2 Duration 类任务（持续执行）

```
护士查看任务列表
    ↓
护士选择任务，扫码验证（可选）
    ↓
验证通过，开始执行
    ↓
更新任务状态为 Running
    ├── ActualStartTime = DateTime.UtcNow
    ├── ExecutorStaffId = 当前护士ID
    └── Status = "Running"
    ↓
持续执行中...
    ↓
护士再次扫码或点击结束
    ↓
更新任务状态为 Completed
    ├── ActualEndTime = DateTime.UtcNow
    ├── CompleterNurseId = 当前护士ID（可能与ExecutorStaffId不同）
    └── Status = "Completed"
```

#### 2.4.3 ResultPending 类任务（等待结果）

```
护士查看任务列表
    ↓
护士选择任务，扫码验证（可选）
    ↓
验证通过，开始执行
    ↓
更新任务状态为 Running
    ├── ActualStartTime = DateTime.UtcNow
    ├── ExecutorStaffId = 当前护士ID
    └── Status = "Running"
    ↓
护士录入结果数据
    ├── 血糖监测：Value + Unit + Note
    ├── 血压监测：Systolic + Diastolic + Note
    ├── 体温监测：Value + Unit + Note
    ├── 尿量监测：Value + Unit + Note
    ├── 意识状态评估：Level + Description + Note
    └── 疼痛评估：Score + Level + Note
    ↓
提交结果
    ↓
更新任务状态为 Completed
    ├── ActualEndTime = DateTime.UtcNow
    ├── CompleterNurseId = 当前护士ID
    ├── ResultPayload = JSON序列化的结果数据
    └── Status = "Completed"
```

**结果数据模板生成：**

```341:353:backend/CareFlow.Application/Services/MedicalOrder/OperationExecutionTaskFactory.cs
        private string? GenerateResultPayloadTemplate(string opId)
        {
            return opId switch
            {
                "OP003" => JsonSerializer.Serialize(new { Value = 0.0, Unit = "mmol/L", Note = "" }), // 血糖监测：数值+单位+备注
                "OP016" => JsonSerializer.Serialize(new { Systolic = 0, Diastolic = 0, Note = "" }), // 血压监测：收缩压+舒张压+备注
                "OP017" => JsonSerializer.Serialize(new { Value = 0.0, Unit = "℃", Note = "" }), // 体温监测：数值+单位+备注
                "OP018" => JsonSerializer.Serialize(new { Value = 0.0, Unit = "ml", Note = "" }), // 尿量监测：数值+单位+备注
                "OP019" => JsonSerializer.Serialize(new { Level = "", Description = "", Note = "" }), // 意识状态评估：等级+描述+备注
                "OP020" => JsonSerializer.Serialize(new { Score = 0, Level = "", Note = "" }), // 疼痛评估：评分+等级+备注
                _ => null // 其他操作不需要结果模板
            };
        }
```

### 2.5 医嘱状态更新流程

**当所有任务完成时，自动更新医嘱状态：**

```127:163:backend/CareFlow.Application/Services/MedicalOrder/OperationOrderTaskService.cs
        /// <summary>
        /// 检查所有任务是否完成，如果完成则更新医嘱的EndTime
        /// </summary>
        public async Task CheckAndUpdateOrderStatusAsync(long orderId)
        {
            try
            {
                var order = await _operationOrderRepository.GetByIdAsync(orderId);
                if (order == null) return;

                // 查询该医嘱的所有任务
                var allTasks = await _taskRepository.ListAsync(t => t.MedicalOrderId == orderId);
                
                if (!allTasks.Any())
                {
                    _logger.LogWarning("医嘱 {OrderId} 没有关联的任务", orderId);
                    return;
                }

                // 检查是否所有任务都已完成（Completed或Cancelled）
                var incompleteTasks = allTasks.Where(t => 
                    t.Status != "Completed" && 
                    t.Status != "Cancelled" && 
                    t.Status != "Skipped").ToList();

                if (!incompleteTasks.Any() && !order.EndTime.HasValue)
                {
                    // 所有任务都已完成，更新EndTime
                    order.EndTime = DateTime.UtcNow;
                    order.Status = "Completed";
                    await _operationOrderRepository.UpdateAsync(order);
                    _logger.LogInformation("医嘱 {OrderId} 的所有任务已完成，已更新EndTime", orderId);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "检查并更新医嘱状态失败，OrderId: {OrderId}", orderId);
                // 不抛出异常，避免影响主流程
            }
        }
```

### 2.6 任务刷新和回滚流程

#### 2.6.1 刷新任务（医嘱变更后）

```
医嘱变更（如修改频次、时间等）
    ↓
POST /api/OperationOrderTask/{orderId}/refresh
    ↓
OperationOrderTaskService.RefreshExecutionTasksAsync()
    ├── 1. 回滚旧任务（删除Pending和Running状态的任务）
    └── 2. 生成新任务（基于新的医嘱配置）
```

**关键代码：**

```165:176:backend/CareFlow.Application/Services/MedicalOrder/OperationOrderTaskService.cs
        public async Task RefreshExecutionTasksAsync(OperationOrder order)
        {
            if (order == null) throw new ArgumentNullException(nameof(order));
            
            _logger.LogInformation("正在刷新医嘱 {OrderId} 的任务...", order.Id);
            
            // 1. 回滚旧任务
            await RollbackPendingTasksAsync(order.Id, "医嘱变更重置");
            
            // 2. 生成新任务
            await GenerateExecutionTasksAsync(order);
        }
```

#### 2.6.2 回滚任务（取消未执行任务）

```
POST /api/OperationOrderTask/{orderId}/rollback
    ↓
OperationOrderTaskService.RollbackPendingTasksAsync()
    ├── 1. 查询所有未完成的任务（Pending和Running状态）
    ├── 2. 删除任务相关的条形码索引
    ├── 3. 删除任务（物理删除）
    └── 4. 删除医嘱（物理删除）
```

**关键代码：**

```178:240:backend/CareFlow.Application/Services/MedicalOrder/OperationOrderTaskService.cs
        public async Task RollbackPendingTasksAsync(long orderId, string reason)
        {
            if (orderId <= 0) throw new ArgumentException("ID无效");

            _logger.LogInformation("回滚医嘱 {OrderId} 的未完成任务，原因: {Reason}", orderId, reason);

            // 查询所有未完成的任务（Pending和Running状态）
            var incompleteTasks = await _taskRepository.ListAsync(t => 
                t.MedicalOrderId == orderId && 
                (t.Status == "Pending" || t.Status == "Running"));

            if (!incompleteTasks.Any())
            {
                _logger.LogInformation("医嘱 {OrderId} 没有需要回滚的任务", orderId);
                return;
            }

            int deletedCount = 0;
            foreach (var task in incompleteTasks)
            {
                try
                {
                    // 1. 删除任务相关的条形码索引
                    var barcodeId = $"Exec-{task.Id}";
                    var barcode = await _barcodeRepository.GetByIdAsync(barcodeId);
                    if (barcode != null)
                    {
                        await _barcodeRepository.DeleteAsync(barcode);
                        _logger.LogDebug("已删除任务 {TaskId} 的条形码索引", task.Id);
                    }

                    // 2. 删除任务（物理删除）
                    await _taskRepository.DeleteAsync(task);
                    deletedCount++;

                    _logger.LogDebug("已删除任务 {TaskId}，计划时间: {PlannedTime}", 
                        task.Id, task.PlannedStartTime);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "删除任务 {TaskId} 失败", task.Id);
                    // 单个任务删除失败不影响其他任务
                }
            }

            _logger.LogInformation("医嘱 {OrderId} 回滚完成，共删除 {Count} 个任务", orderId, deletedCount);

            // 3. 删除医嘱（物理删除）
            try
            {
                var order = await _operationOrderRepository.GetByIdAsync(orderId);
                if (order != null)
                {
                    await _operationOrderRepository.DeleteAsync(order);
                    _logger.LogInformation("已删除医嘱 {OrderId}", orderId);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "删除医嘱 {OrderId} 失败", orderId);
                throw; // 医嘱删除失败应该抛出异常
            }
        }
```

## 三、API 端点汇总

### 3.1 操作医嘱创建

**POST /api/OperationOrder/create**
- 功能：创建操作医嘱，自动分配护士并生成执行任务
- 请求体：`CreateOperationOrderRequestDto`
- 响应：包含 OrderId、AssignedNurseId 等信息

### 3.2 任务管理

**POST /api/OperationOrderTask/generate**
- 功能：为操作医嘱生成执行任务
- 请求体：`{ "OperationOrderId": 123 }`
- 响应：任务列表

**POST /api/OperationOrderTask/{orderId}/refresh**
- 功能：刷新任务（医嘱变更后）
- 响应：成功/失败消息

**POST /api/OperationOrderTask/{orderId}/rollback**
- 功能：回滚未完成任务
- 请求体：回滚原因（字符串）
- 响应：成功/失败消息

**GET /api/OperationOrderTask/{orderId}/tasks**
- 功能：查询医嘱的所有任务
- 响应：任务列表

**GET /api/OperationOrderTask/task/{taskId}/barcode**
- 功能：获取任务条形码图片
- 响应：PNG 格式的条形码图片

### 3.3 条形码验证（复用现有）

**POST /api/BarcodeMatching/validate**
- 功能：验证执行任务条形码和患者条形码匹配
- 请求体：multipart/form-data（两个条形码图片文件）
- 响应：匹配结果（患者ID、任务ID、时间验证等）

## 四、关键设计要点

### 4.1 独立入口设计
- 不修改 `MedicalOrderController` 和 `MedicalOrderManager`
- 独立的 `OperationOrderController` 和 `OperationOrderManager`
- 独立的 `OperationOrderTaskService` 和 `OperationExecutionTaskFactory`

### 4.2 任务类别自动分配
- 根据操作代码（OpId）自动分配任务类别（Immediate/Duration/ResultPending）
- 支持20种常见操作（OP001-OP020）

### 4.3 频次类型支持
- **长期医嘱**：`"x天y次"` 格式（如 `"1天3次"`、`"2天1次"`）
- **临时医嘱**：`"一次性"` 格式
- 时间点支持逗号或分号分隔（如 `"08:00,12:00,16:00"`）

### 4.4 时间验证和过滤
- 临时医嘱：如果时间已过，报错且不产生任务
- 长期医嘱：自动删除时间已过的任务，保留未来任务

### 4.5 条形码集成
- 每个任务自动生成条形码索引
- 支持扫码验证患者身份
- 支持获取任务条形码图片

### 4.6 结果数据模板
- ResultPending 类任务包含结果数据模板（在 DataPayload 中）
- 护士只需填写核心结果数据
- 结果数据存储在 ResultPayload 中

### 4.7 自动状态更新
- 所有任务完成时，自动更新医嘱的 EndTime 和 Status

## 五、数据流图

```
┌─────────────────┐
│   医生创建医嘱    │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ OperationOrder  │ (保存到数据库)
│   Controller    │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│OperationOrder   │
│   Manager       │
│ 1. 保存医嘱      │
│ 2. 分配护士      │
│ 3. 生成任务      │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│OperationOrder   │
│  TaskService    │
│ 1. 验证医嘱      │
│ 2. 调用工厂      │
│ 3. 保存任务      │
│ 4. 生成条形码    │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│OperationExecution│
│  TaskFactory     │
│ 1. 解析频次      │
│ 2. 计算时间      │
│ 3. 创建任务      │
│ 4. 验证时间      │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ ExecutionTasks  │ (保存到数据库)
│  + BarcodeIndex │ (保存到数据库)
└─────────────────┘
         │
         ▼
┌─────────────────┐
│   护士执行任务    │
│ 1. 查看任务列表   │
│ 2. 扫码验证      │
│ 3. 执行任务      │
│ 4. 录入结果      │
│ 5. 完成任务      │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 更新任务状态     │
│ 检查医嘱状态     │
└─────────────────┘
```

## 六、示例场景

### 场景1：长期医嘱 - 每天3次血糖监测

**医嘱配置：**
- OpId: `"OP003"`（血糖监测）
- IsLongTerm: `true`
- FrequencyType: `"1天3次"`
- FrequencyValue: `"08:00,14:00,20:00"`
- PlantEndTime: `2024-01-05 23:59:59`
- CreateTime: `2024-01-01 10:00:00`

**生成任务：**
- 任务数量：5天 × 3次 = 15个任务
- 任务类别：`ResultPending`（需要录入结果）
- 任务时间：
  - 2024-01-01 08:00, 14:00, 20:00
  - 2024-01-02 08:00, 14:00, 20:00
  - 2024-01-03 08:00, 14:00, 20:00
  - 2024-01-04 08:00, 14:00, 20:00
  - 2024-01-05 08:00, 14:00, 20:00

**执行流程：**
1. 护士在08:00扫码开始任务
2. 测量血糖值（如 5.5 mmol/L）
3. 录入结果：`{ "Value": 5.5, "Unit": "mmol/L", "Note": "餐前" }`
4. 提交结果，任务完成

### 场景2：临时医嘱 - 立即更换引流袋

**医嘱配置：**
- OpId: `"OP001"`（更换引流袋）
- IsLongTerm: `false`
- FrequencyType: `"一次性"`
- FrequencyValue: `"立即"`
- PlantEndTime: `2024-01-01 23:59:59`
- CreateTime: `2024-01-01 14:30:00`

**生成任务：**
- 任务数量：1个任务
- 任务类别：`Immediate`（扫码即完成）
- 任务时间：`2024-01-01 14:30:00`（当前时间）

**执行流程：**
1. 护士扫码开始任务
2. 立即完成（扫码即完成）
3. 任务状态自动更新为 Completed

### 场景3：长期医嘱 - 持续吸氧

**医嘱配置：**
- OpId: `"OP002"`（持续吸氧）
- IsLongTerm: `true`
- FrequencyType: `"1天1次"`
- FrequencyValue: `"08:00"`
- PlantEndTime: `2024-01-03 23:59:59`
- CreateTime: `2024-01-01 10:00:00`

**生成任务：**
- 任务数量：3个任务（每天1次，共3天）
- 任务类别：`Duration`（持续执行）
- 任务时间：
  - 2024-01-01 08:00
  - 2024-01-02 08:00
  - 2024-01-03 08:00

**执行流程：**
1. 护士在08:00扫码开始任务
2. 开始吸氧（持续执行中）
3. 护士再次扫码或点击结束
4. 任务完成

## 七、总结

操作类医嘱系统实现了完整的医嘱创建、任务生成、执行和状态管理流程。核心特点包括：

1. **自动化流程**：医嘱创建后自动分配护士并生成执行任务
2. **灵活的任务生成**：支持长期和临时医嘱，支持多种频次类型
3. **智能时间管理**：自动计算任务时间，过滤已过时间
4. **条形码集成**：支持扫码验证患者身份
5. **结果数据管理**：ResultPending 类任务支持结构化结果录入
6. **状态自动更新**：任务完成后自动更新医嘱状态

整个系统设计独立、模块化，易于维护和扩展。

