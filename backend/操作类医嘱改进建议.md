# 操作类医嘱改进建议

## 一、对比药品类医嘱和操作类医嘱的完整流程

### 1. 药品类医嘱的完整流程

#### 1.1 创建医嘱流程
- ✅ 参数验证（医嘱列表不能为空）
- ✅ 业务验证（ValidateOrderDto）
  - 时间策略验证（IMMEDIATE/SPECIFIC/CYCLIC/SLOTS）
  - 药品验证（至少一个药品）
- ✅ 创建医嘱实体
- ✅ 保存医嘱
- ✅ 插入状态历史记录（Draft → PendingReceive）
- ✅ 分配负责护士

#### 1.2 签收医嘱流程
- ✅ 验证医嘱状态（PendingReceive、Rejected、PendingStop）
- ✅ 特殊验证：出院医嘱前置验证
- ✅ 更新医嘱状态（PendingReceive → Accepted）
- ✅ 插入状态历史记录
- ✅ 生成执行任务（签收时生成）
- ✅ 分配责任护士（为每个任务）
- ✅ 生成条形码（为每个任务）

#### 1.3 任务生成流程
- ✅ 验证医嘱真实性（从数据库查询，包含Items和Drug信息）
- ✅ 验证医嘱状态（不能是Cancelled、Completed、Stopped、Draft、Rejected）
- ✅ 验证必要字段（ValidateOrderFields）
  - 患者ID、医生ID
  - 药品Items不能为空
  - 给药途径验证
  - 时间策略特定验证
- ✅ 检查是否已存在未完成的任务（HasPendingTasksAsync）
  - 检查状态：Applying、Applied、AppliedConfirmed、Pending、InProgress
- ✅ 根据时间策略生成任务（IMMEDIATE/SPECIFIC/CYCLIC/SLOTS）
- ✅ 批量保存任务

#### 1.4 停止医嘱流程
- ✅ 验证医嘱状态（PendingReceive、Accepted、InProgress、Stopped）
- ✅ 未签收医嘱：直接取消（PendingReceive → Cancelled）
- ✅ 已签收医嘱：改为PendingStop
- ✅ 验证停止节点任务
- ✅ 锁定任务（保存StatusBeforeLocking，改为OrderStopping）
  - 锁定状态：Applying、Applied、AppliedConfirmed、Pending、InProgress
- ✅ 插入状态历史记录

#### 1.5 签收停止医嘱流程
- ✅ 更新医嘱状态（PendingStop → Stopped）
- ✅ 处理被锁定的任务
  - 检查StatusBeforeLocking是否为Applied或AppliedConfirmed
  - 如果是，创建退药申请，任务改为PendingReturn
  - 否则，任务改为Stopped
- ✅ 插入状态历史记录

#### 1.6 退回医嘱流程
- ✅ 验证医嘱状态（只能退回PendingReceive状态）
- ✅ 更新医嘱状态（PendingReceive → Rejected）
- ✅ 记录退回原因和时间
- ✅ 插入状态历史记录

---

### 2. 操作类医嘱的当前实现

#### 2.1 创建医嘱流程
- ✅ 参数验证（医嘱列表不能为空）
- ✅ 业务验证（ValidateOrderDto）
  - 时间策略验证（IMMEDIATE/SPECIFIC/CYCLIC/SLOTS）
  - 操作代码验证
- ✅ 创建医嘱实体
- ✅ 保存医嘱
- ✅ 插入状态历史记录（Draft → PendingReceive）
- ✅ 分配负责护士

#### 2.2 签收医嘱流程
- ✅ 验证医嘱状态（PendingReceive、Rejected、PendingStop）
- ❌ **缺少：特殊验证（如出院医嘱的前置验证）** - 操作类医嘱不需要，但流程一致
- ✅ 更新医嘱状态（PendingReceive → Accepted）
- ✅ 插入状态历史记录
- ✅ 生成执行任务（签收时生成）
- ✅ 分配责任护士（为每个任务）
- ✅ 生成条形码（为每个任务）

#### 2.3 任务生成流程
- ✅ 验证医嘱真实性（从数据库查询）
- ✅ 验证医嘱状态（不能是Cancelled、Completed、Stopped、Draft、Rejected）
- ✅ 验证必要字段（ValidateOrderFields）
  - 患者ID、医生ID
  - 操作代码、操作名称
  - 时间策略特定验证
- ⚠️ **问题1：HasPendingTasksAsync检查的状态不完整**
  - 当前只检查：Pending、InProgress
  - 药品类医嘱检查：Applying、Applied、AppliedConfirmed、Pending、InProgress
  - **说明**：操作类医嘱没有取药任务（Verification类别），所以不需要检查Applying/Applied/AppliedConfirmed状态。这个差异是合理的，但为了保持一致性，建议明确注释说明。
- ✅ 根据时间策略生成任务（IMMEDIATE/SPECIFIC/CYCLIC/SLOTS）
- ✅ 批量保存任务

#### 2.4 停止医嘱流程
- ✅ 验证医嘱状态（PendingReceive、Accepted、InProgress、Stopped）
- ✅ 未签收医嘱：直接取消（PendingReceive → Cancelled）
- ✅ 已签收医嘱：改为PendingStop
- ✅ 验证停止节点任务
- ⚠️ **问题2：锁定任务的状态检查可能不完整**
  - 药品类医嘱锁定：Applying、Applied、AppliedConfirmed、Pending、InProgress
  - 操作类医嘱应该锁定：Pending、InProgress（因为没有取药任务）
  - **说明**：这个差异是合理的，但需要确认停止医嘱的通用逻辑是否正确处理了操作类医嘱。

#### 2.5 签收停止医嘱流程
- ✅ 更新医嘱状态（PendingStop → Stopped）
- ✅ 处理被锁定的任务
  - 检查StatusBeforeLocking是否为Applied或AppliedConfirmed
  - 如果是，创建退药申请，任务改为PendingReturn
  - 否则，任务改为Stopped
- ⚠️ **问题3：操作类医嘱不应该有退药逻辑**
  - 药品类医嘱签收停止时，如果任务状态是Applied或AppliedConfirmed，需要退药
  - 操作类医嘱不应该有Applied/AppliedConfirmed状态（因为没有取药任务）
  - **说明**：这个逻辑在通用服务中，对操作类医嘱应该不会有影响，但需要确认。

#### 2.6 退回医嘱流程
- ✅ 验证医嘱状态（只能退回PendingReceive状态）
- ✅ 更新医嘱状态（PendingReceive → Rejected）
- ✅ 记录退回原因和时间
- ✅ 插入状态历史记录

---

## 二、需要改进的地方

### 🔴 问题1：任务生成时的状态检查不一致

**位置**：`OperationOrderTaskService.HasPendingTasksAsync()`

**当前实现**：
```csharp
var existingTasks = await _taskRepository.ListAsync(t => 
    t.MedicalOrderId == orderId && 
    (t.Status == ExecutionTaskStatus.Pending || 
     t.Status == ExecutionTaskStatus.InProgress));
```

**药品类医嘱实现**：
```csharp
var existingTasks = await _taskRepository.ListAsync(t => 
    t.MedicalOrderId == orderId && 
    (t.Status == ExecutionTaskStatus.Applying || 
     t.Status == ExecutionTaskStatus.Applied || 
     t.Status == ExecutionTaskStatus.AppliedConfirmed || 
     t.Status == ExecutionTaskStatus.Pending || 
     t.Status == ExecutionTaskStatus.InProgress));
```

**改进建议**：
- 操作类医嘱没有取药任务，所以不需要检查Applying/Applied/AppliedConfirmed状态
- 但为了保持代码清晰，建议添加注释说明为什么只检查这两个状态
- 或者，可以考虑检查所有未完成状态，但明确说明操作类医嘱不会出现Applying/Applied/AppliedConfirmed状态

**改进代码**：
```csharp
/// <summary>
/// 检查是否已存在未完成的任务，避免重复生成
/// 注意：操作类医嘱没有取药任务（Verification类别），所以不需要检查Applying/Applied/AppliedConfirmed状态
/// </summary>
private async Task<bool> HasPendingTasksAsync(long orderId)
{
    try
    {
        // 操作类医嘱的任务状态只有四种：Pending、InProgress、Completed、Stopped
        // 不包含取药相关的状态（Applying、Applied、AppliedConfirmed）
        var existingTasks = await _taskRepository.ListAsync(t => 
            t.MedicalOrderId == orderId && 
            (t.Status == ExecutionTaskStatus.Pending || 
             t.Status == ExecutionTaskStatus.InProgress));

        var hasPending = existingTasks.Any();
        
        if (hasPending)
        {
            _logger.LogWarning("医嘱 {OrderId} 已存在 {TaskCount} 个未完成的执行任务", 
                orderId, existingTasks.Count());
        }

        return hasPending;
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "检查医嘱 {OrderId} 的待执行任务时发生错误", orderId);
        return false; // 发生错误时不阻止任务生成，但会记录日志
    }
}
```

---

### 🔴 问题2：回滚任务时的状态检查不一致

**位置**：`OperationOrderTaskService.RollbackPendingTasksAsync()`

**当前实现**：
```csharp
var pendingTasks = await _taskRepository.ListAsync(t => 
    t.MedicalOrderId == orderId && 
    (t.Status == ExecutionTaskStatus.Pending || 
     t.Status == ExecutionTaskStatus.InProgress) && 
    t.ActualStartTime == null);
```

**药品类医嘱实现**：
```csharp
var pendingTasks = await _taskRepository.ListAsync(t => 
    t.MedicalOrderId == orderId && 
    (t.Status == ExecutionTaskStatus.Applying || 
     t.Status == ExecutionTaskStatus.Applied || 
     t.Status == ExecutionTaskStatus.AppliedConfirmed || 
     t.Status == ExecutionTaskStatus.Pending) && 
    t.ActualStartTime == null);
```

**改进建议**：
- 操作类医嘱的回滚逻辑应该检查所有未开始执行的任务
- 当前实现缺少Running状态的检查（如果任务已经开始但未完成）
- 建议添加Running状态检查，或者明确说明为什么只检查这两个状态

**改进代码**：
```csharp
// 查找所有未开始执行的任务
// 注意：操作类医嘱没有取药任务，所以不需要检查Applying/Applied/AppliedConfirmed状态
var pendingTasks = await _taskRepository.ListAsync(t => 
    t.MedicalOrderId == orderId && 
    (t.Status == ExecutionTaskStatus.Pending || 
     t.Status == ExecutionTaskStatus.InProgress ||
     t.Status == ExecutionTaskStatus.Running) && // 添加Running状态检查
    t.ActualStartTime == null); // 只回滚未开始执行的任务
```

---

### 🟡 问题3：停止医嘱时的任务锁定逻辑

**位置**：`MedicalOrderQueryService.StopOrderAsync()`（通用服务）

**当前实现**（药品类医嘱）：
```csharp
var tasksToLock = allTasks
    .Skip(stopAfterIndex)
    .Where(t => t.Status == ExecutionTaskStatus.Applying 
             || t.Status == ExecutionTaskStatus.Applied
             || t.Status == ExecutionTaskStatus.AppliedConfirmed
             || t.Status == ExecutionTaskStatus.Pending
             || t.Status == ExecutionTaskStatus.InProgress);
```

**问题**：
- 这个逻辑在通用服务中，对所有医嘱类型都适用
- 操作类医嘱没有Applying/Applied/AppliedConfirmed状态，所以这些条件对操作类医嘱无效
- 但逻辑上应该没问题，因为操作类医嘱的任务状态只可能是Pending或InProgress

**改进建议**：
- 当前实现应该是正确的，因为操作类医嘱的任务不会匹配到Applying/Applied/AppliedConfirmed条件
- 但为了代码清晰，可以考虑根据医嘱类型动态决定要锁定的状态
- 或者，保持当前实现，因为OR条件不会影响操作类医嘱

---

### 🟡 问题4：签收停止医嘱时的退药逻辑

**位置**：`OrderAcknowledgementService.AcknowledgeStoppedOrderAsync()`（通用服务）

**当前实现**：
```csharp
if (statusBeforeLocking == ExecutionTaskStatus.Applied ||
    statusBeforeLocking == ExecutionTaskStatus.AppliedConfirmed)
{
    // 创建退药申请记录
    // 任务状态改为PendingReturn
}
else
{
    // 任务状态改为Stopped
}
```

**问题**：
- 操作类医嘱的任务不会出现Applied或AppliedConfirmed状态
- 所以操作类医嘱的停止签收会直接走到else分支，任务改为Stopped
- 这个逻辑应该是正确的

**改进建议**：
- 当前实现应该是正确的
- 但可以考虑添加医嘱类型判断，明确区分药品类医嘱和操作类医嘱的处理逻辑
- 或者，保持当前实现，因为操作类医嘱不会匹配到退药条件

---

### 🟢 问题5：任务生成时的验证逻辑完整性

**位置**：`OperationOrderTaskService.ValidateOrderFields()`

**当前实现**：
- ✅ 检查必要字段（患者ID、医生ID、操作代码、操作名称）
- ✅ 检查时间字段（结束时间不能早于当前时间，开始时间不能晚于结束时间）
- ✅ 根据时间策略验证特定字段

**对比药品类医嘱**：
- ✅ 药品类医嘱还检查：Items不能为空、给药途径验证
- ✅ 操作类医嘱检查：操作代码、操作名称（对应药品的Items）

**结论**：
- 验证逻辑是完整的，对应关系正确
- 操作类医嘱不需要检查Items和给药途径，因为操作类医嘱没有这些字段

---

### 🟢 问题6：时间策略验证

**位置**：`OperationOrderService.ValidateOrderDto()` 和 `OperationOrderTaskService.ValidateOrderFields()`

**当前实现**：
- ✅ IMMEDIATE：不需要特殊验证
- ✅ SPECIFIC：需要StartTime，且必须是未来时间
- ✅ CYCLIC：需要StartTime和IntervalHours，IntervalHours不能超过168小时
- ✅ SLOTS：需要StartTime和SmartSlotsMask，且必须匹配到有效时段

**对比药品类医嘱**：
- ✅ 验证逻辑完全一致

**结论**：
- 时间策略验证是完整的，与药品类医嘱一致

---

## 三、总结

### ✅ 已经正确实现的部分
1. 创建医嘱流程（参数验证、业务验证、状态历史记录）
2. 签收医嘱流程（状态验证、任务生成、护士分配、条形码生成）
3. 任务生成流程（医嘱验证、字段验证、时间策略支持）
4. 停止医嘱流程（状态验证、任务锁定）
5. 签收停止医嘱流程（状态更新、任务处理）
6. 退回医嘱流程（状态验证、原因记录）

### ⚠️ 需要改进的部分

#### 1. **HasPendingTasksAsync方法** - 状态检查
- **问题**：已修复，操作类医嘱只使用Pending和InProgress状态
- **说明**：操作类医嘱的任务状态只有四种：Pending、InProgress、Completed、Stopped，不使用Running状态
- **改进**：已添加注释说明操作类医嘱的状态限制

#### 2. **RollbackPendingTasksAsync方法** - 状态检查
- **问题**：已修复，操作类医嘱只使用Pending和InProgress状态
- **说明**：操作类医嘱的任务状态只有四种：Pending、InProgress、Completed、Stopped，不使用Running状态
- **改进**：已添加注释说明操作类医嘱的状态限制

#### 3. **代码注释和文档**
- **问题**：缺少说明为什么操作类医嘱不需要检查某些状态
- **改进**：添加详细注释，说明操作类医嘱和药品类医嘱的差异

### 🔍 需要确认的部分

#### 1. **停止医嘱时的任务锁定逻辑**
- **问题**：通用服务中的锁定逻辑包含了Applying/Applied/AppliedConfirmed状态
- **确认**：操作类医嘱的任务不会匹配到这些条件，所以逻辑应该是正确的
- **建议**：可以考虑根据医嘱类型动态决定要锁定的状态，或者保持当前实现并添加注释

#### 2. **签收停止医嘱时的退药逻辑**
- **问题**：通用服务中的退药逻辑检查Applied/AppliedConfirmed状态
- **确认**：操作类医嘱的任务不会出现这些状态，所以不会触发退药逻辑
- **建议**：可以考虑添加医嘱类型判断，明确区分处理逻辑

---

## 四、具体改进代码

### 改进1：HasPendingTasksAsync方法

```csharp
/// <summary>
/// 检查是否已存在未完成的任务，避免重复生成
/// 注意：操作类医嘱没有取药任务（Verification类别），所以不需要检查Applying/Applied/AppliedConfirmed状态
/// </summary>
private async Task<bool> HasPendingTasksAsync(long orderId)
{
    try
    {
        // 操作类医嘱的任务状态只有四种：Pending、InProgress、Completed、Stopped
        // 不包含取药相关的状态（Applying、Applied、AppliedConfirmed）
        var existingTasks = await _taskRepository.ListAsync(t => 
            t.MedicalOrderId == orderId && 
            (t.Status == ExecutionTaskStatus.Pending || 
             t.Status == ExecutionTaskStatus.InProgress));

        var hasPending = existingTasks.Any();
        
        if (hasPending)
        {
            _logger.LogWarning("医嘱 {OrderId} 已存在 {TaskCount} 个未完成的执行任务", 
                orderId, existingTasks.Count());
        }

        return hasPending;
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "检查医嘱 {OrderId} 的待执行任务时发生错误", orderId);
        return false; // 发生错误时不阻止任务生成，但会记录日志
    }
}
```

### 改进2：RollbackPendingTasksAsync方法

```csharp
public async Task RollbackPendingTasksAsync(long orderId, string reason)
{
    // ... 前面的验证代码保持不变 ...

    try
    {
        // 查找所有未开始执行的任务
        // 注意：操作类医嘱没有取药任务，所以不需要检查Applying/Applied/AppliedConfirmed状态
        // 只检查Pending、InProgress状态，且ActualStartTime为null（未开始执行）
        // 操作类医嘱的任务状态只有四种：Pending、InProgress、Completed、Stopped
            var pendingTasks = await _taskRepository.ListAsync(t => 
                t.MedicalOrderId == orderId && 
                (t.Status == ExecutionTaskStatus.Pending || 
                 t.Status == ExecutionTaskStatus.InProgress) &&
            t.ActualStartTime == null); // 只回滚未开始执行的任务

        foreach (var task in pendingTasks)
        {
            // 更新状态为Stopped，不物理删除
            // 注意：条形码不删除，与药品类医嘱保持一致
            task.Status = ExecutionTaskStatus.Stopped;
            task.ExceptionReason = $"医嘱停止: {reason}";
            task.IsRolledBack = true;
            task.LastModifiedAt = DateTime.UtcNow;
            
            await _taskRepository.UpdateAsync(task);
        }

        _logger.LogInformation("已回滚医嘱 {OrderId} 的 {TaskCount} 个未执行任务", orderId, pendingTasks.Count());

        // ... 后面的代码保持不变 ...
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "回滚医嘱 {OrderId} 的任务时发生错误", orderId);
        throw;
    }
}
```

---

## 五、其他建议

### 1. 代码一致性
- 建议在操作类医嘱的服务中添加注释，明确说明与药品类医嘱的差异
- 建议统一错误消息格式，与药品类医嘱保持一致

### 2. 测试覆盖
- 建议添加单元测试，验证HasPendingTasksAsync和RollbackPendingTasksAsync的正确性
- 建议测试不同状态的任务（Pending、InProgress）的处理逻辑

### 3. 文档完善
- 建议更新操作类医嘱的流程文档，明确说明与药品类医嘱的差异
- 建议在代码中添加XML注释，说明每个方法的用途和注意事项

